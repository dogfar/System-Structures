## Tomasulo

###### 计71 张程远 2017011429

### 1 模拟器实现思路

下面结合代码实现，介绍模拟器各个组成部分的思路。

##### 1.1 功能部件与辅助函数

首先，各个指令的构件不同，有的需要三个寄存器，有的需要寄存器和操作数。为此，统一定义一个struct Instr来代表命令，其包含一个int op代表操作类型（五种basic操作分别用5个整数代表），int r1, r2, r3代表指令用到的3个寄存器编号，int opnum代表操作数。对于四则运算的指令而言，结构体中的opnum用不到；而对于load而言，用到了opnum和r1。这样虽然浪费了一点空间，但是可以简化代码。从NEL文件中读入所有指令之后，统计指令条数记为cnt，然后把指令存储在vector\<Instr\>里，以便之后开始模拟运行。

接下来介绍保留站、寄存器结果和寄存器实际值。保留站用int resevStation\[13\]\[8\]表示，其中resevStation[1-6]是加法器的保留站，7-9是乘法器的保留站，10-12是loader的保留站。具体到每一个resevStation[i]，内容如下表所示。

|          | 0        | 1      | 2        | 3-4         | 5-6        | 7        |
| -------- | -------- | ------ | -------- | ----------- | ---------- | -------- |
| 四则运算 | 指令编号 | 是否忙 | 操作符   | 源操作数    | 来自哪个RS | 剩余时间 |
| Load     | 指令编号 | 是否忙 | 源操作数 | (3)剩余时间 |            |          |

其中5-6记录的值是保留站的编号i，0 < i < 13。如果5-6没有值，就把它设成-1。这里之所以把load和其他运算统一，是为了四则运算的5-6项实现方便，直接用保留站编号就可以指定。第0项指令编号是为了在指令操作完成时（比如执行完成），能及时更新status表中的记录。其他项目与课件中的介绍功能一致。

Regresult记录当前寄存器正在等待哪个RS的结果，Regs记录当前寄存器的值。然后是usingadder、usingloader和usingmulter，代表实际运算部件的执行情况，其中如果部件空闲则值为-1，否则值为正在执行的指令序号。

Hextoint和getregnum函数只在openfile函数中被调用，用来解析读入的字符串，并把它们处理成Instr的形式储存到vector里面。prettyprinter用来打印每个clock结束后保留站、寄存器等待结果、寄存器和指令执行状态表的值，一方面是为了debug方便，另一方面也是为了实现查询clock的需求。

##### 1.2 实现逻辑

模拟器以clock为主循环，处理每个clock发生的事。由于一个clock发生的事可能太多，比如指令写回、指令发射、执行完成并让出功能单元等等，这些事在软件模拟中必须要有先后顺序，否则会互相影响操作的结果，所以根据讨论，首先模拟器执行写回操作，然后让出执行完成的功能单元，然后再发射新的指令进入模拟器。主逻辑也是按照这个顺序执行的。

首先遍历RS，找到剩余时间为0的指令，因为这些指令在上个clock结束的时候运行时间刚刚被减为0，故这个clock它们应该已经写回完毕。根据操作数和操作符算出最终的结果，然后检查Regresult表中对应的寄存器是否在等待它，如果是则写回到寄存器中。这一步检查是为了避免WAW的冲突，Regresult表只等待最新写入Reg的RS。完成后，我们就可以把这条指令的write back置为clock，并在保留站中把busy设为not，清空操作数的值，并把剩余时间设为-1。然后把运算部件让出来，即查找using数组，其中某一项的值和保留站中存储的指令编号应该相等，把它置为-1。这时保留站中存储的这条指令的编号也没用了，设置为-1。然后再遍历保留站，看有没有项在等它算出来的结果（resevStaion\[j\]\[5\]或\[6\]的值为该保留站的编号i），如果有就把结果传递给它。

然后是执行，再次遍历保留站，找到那些执行时间仍有剩余的项目，把时间-1，代表执行过了一个周期。这里如果执行时间被减到了0，除了在status表中记录comp exec完成的时间之外不做任何操作，因为这个周期末才执行完，还需要一个周期才能写回。

接下来是寻找是否有就绪的指令。在这套实现中，指令就绪等价于对应的保留站里第1项为1且5-7项为-1，即忙碌并且不缺操作数并且没有执行过（对load而言，就绪就是保留站忙且没执行过）。然后为每一项检查对应操作符的using数组里是否有空（值为-1），有空就让指令占有它，并把剩余时间设置为该指令执行所需要的时间。这里从就绪到进入是需要一个周期的，不能把就绪和开始执行混为一谈，因此就绪时剩余时间并没有减少。

最后是发射指令。发射前首先要判断是否还有指令需要发射，也就是now要小于当前的cnt。发射的指令主要有两个逻辑需要判断，第一是是否有保留站空闲，没有就不发射了，now的值也不变；如果有，就让这条指令进入保留站并让now++，这里需要设置保留站的第0项为指令编号，第1项为忙碌，第2项为指令op，然后从regresult检查指令需要的源寄存器是否在等待某个RS，如果是则标记对应5-6的值，否则直接把3-4替换为对应寄存器的值。然后再在regresult中标记要写入的寄存器。注意这里两个操作不能颠倒，因为有读和写入同一个寄存器的指令，否则就是自己永远等待自己了。第二个要判断的地方是如果指令就绪，在发射后能否直接获得实际功能单元，因此遍历对应的using数组，检查是否有-1的项，如果有就让刚发射的指令占有它。

最后一步是检查当前是否模拟完毕。判断标准为now是否已经大于指令条数，并且所有保留站都处于空闲状态。

以上就是整个模拟器中的大致逻辑，在实现过程中还有很多很多需要注意的细节，具体还请参照代码的注释和具体实现。

### 2 Tomasulo的分析

tomasulo算法的核心思想在于，执行顺序是按数据流的方式执行，比如从A、B寄存器取数据计算，把数据存到C里，就可以在AB和C之间连一条有向边，然后给这个图拓扑排序一下，这样执行的顺序相比于指令的顺序就是乱序的。按数据流顺序能够大大优化CPU的使用效率。

tomasulo与记分牌算法的最大差距在于重命名技术。记分牌只能通过插入停顿周期来处理WAR和WAW冲突，而tomasulo则可以通过重命名技术处理。举例而言，有下面两条指令等待发射：

```
ADD R1, R2, R3
ADD R1, R4, R5
```

两条指令都需要写R1，因此这是典型的WAW冲突。记分牌能检测到这一冲突，但它对其束手无策，只能通过停顿解决这一问题。而Tomasulo能让两条指令正常issue，原因在于它把一条指令计算结果的用途分为两种，一种是写入寄存器，一种是传递给其他的指令，只要这两件事能够维护对了就可以。寄存器的结果永远需要最新的指令，而旧指令的结果也能马上传递给需要其的指令。这两件事的维护跟正常issue指令并执行不冲突，第一件事在每次issue后更新就可以，第二件事在执行过后通过总线传值就行。这样就解决了WAW冲突。

按照上面的逻辑，我写了一个test.nel，包含的指令为：

```
LD,R1,0x2
LD,R2,0x1
LD,R3,0x3
ADD,R1,R2,R3
ADD,R1,R1,R2
```

需要注意LD的运算单元不够，以及Tomasulo对于WAW的处理。针对test的log文件在test.basic.log中，详细的处理过程在test.txt中，最后寄存器的处理结果是正确的。

除此之外，Tomasulo与记分牌的不同之处还有以下几点。

（1）Tomasulo检测竞争是通过每一个保留站来进行的，它是一种分布式的处理方法；而记分牌所有检测都是通过记分牌进行的，因此它是一种集中式方法；

（2）tomasulo通过数据总线广播数据结果，而不是把结果写入FP寄存器。

### 3 总结与感想

之前上课听tomasulo算法没有听懂，问别的同学也都不会，于是花了一点时间重新看算法，然后自己又造了两天轮子，终于写出来基础的版本。感觉收获还是很大的，对于tomasulo有了更深刻的了解，对流程把握也比较清楚了。设计过程和实现的代码全部独立完成，成就感也不小，算是尽力而为了。不过感觉自己的理解可能还是有偏差，如果哪里有问题还请助教指出。

运行：
直接编译tomasulo.cpp就可以了。如果需要查看运行的log结果，需要修改位于175行、main函数最开始位置的filename变量为输入文件名。命令行中会按如下格式输出中间变量结果
输入Big_test需要执行下面的命令。

```
g++ tomasulo.cpp -o tomasulo.exe -Wl,--stack=268435456
```

实测运行时间，不开-O2或-O3优化大约在200ms左右，开-O2或-O3编译优化大约在70ms左右。不知道是不是可以更快，因为是按算法来操作的，全部操作都是数组的方式进行。

Clock X
Instructions Using Adder: //(正在使用加法器的指令编号 空闲为-1)
%d %d %d
Instructions Using Multer: //(正在使用乘法器的指令编号 空闲为-1)
%d %d
Instructions Using Loader: //(正在使用loader的指令编号 空闲为-1)
%d %d
ResevStaion Table:
i（1-9） %d（指令id）%d（是否空闲）%d（操作符）%d（源数据1）%d（源数据2）%d（源1来自哪个RS）%d（源2来自哪个RS）%d（剩余执行时间）
...
i（10-12） %d（指令id）%d（是否空闲）%d（源数据）%d（剩余执行时间）
...
RegResult Table:
0 1 2 ... 31（寄存器编号）
%d（等待的RS编号）...
Regs Table:
0 1 2 ... 31
%d（寄存器值）